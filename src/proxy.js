
// «Proxy» — это объект-посредник, который контролирует доступ к другому объекту, перехватывая все вызовы.


// Как это работает? Программист обращается к объекту-посреднику (заместителю) так, будто это нужный ему реальный объект. Объект-посредник пропускает все вызовы к реальному объекту через себя и передает их реальному объекту. Ответы от реального объекта точно так же проходят обратно, возвращаясь к программисту через объект-посредник.
//
//Зачем это нужно? Чтобы была возможность приурочить к конкретному обращению к реальному объекту (вызову) какие-либо действия. Например, с помощью объекта-посредника можно подсчитать количество чтений какого-либо свойства некоего реального объекта за время работы программы. Или можно на любую попытку чтения какого-либо свойства реального объекта выдавать на экран сообщение.

// JS — объектно-ориентированный язык, то есть мы не можем написать код, не используя объекты. Но объекты в JavaScript всегда работают без оболочки, с ними можно делать что угодно. Это, в свою очередь, делает код небезопасным.
//
//С помощью proxy можно найти локального администратора для объекта и расширить исходные функции объекта

// let proxy = new Proxy(target, handler);

//target – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
//handler – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка get – для чтения свойства из target, ловушка set – для записи свойства в target и так далее.

// let target = {};
// let proxy = new Proxy(target, {}); // пустой handler
//
// proxy.test = 5; // записываем в прокси (1)
// console.log(target.test); // 5, свойство появилось в target!
//
// console.log(proxy.test); // 5, мы также можем прочитать его из прокси (2)
//
// for(let key in proxy) console.log(key); // test, итерация работает (3)


// При операциях над proxy, если в handler имеется соответствующая «ловушка», то она срабатывает, и прокси имеет возможность по-своему обработать её, иначе операция будет совершена над оригинальным объектом target.

//     Запись свойства proxy.test = устанавливает значение на target. - target.test
//     Чтение свойства proxy.test возвращает значение из target.
//     Итерация по proxy возвращает значения из target.


// Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять. Например, [[Get]] – внутренний метод для чтения свойства, [[Set]] – для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к ним по имени.
//
//Ловушки как раз перехватывают вызовы этих внутренних методов.
//
//Для каждого внутреннего метода в этой таблице указана ловушка, то есть имя метода, который мы можем добавить в параметр handler при создании new Proxy, чтобы перехватывать данную операцию:
// https://learn.javascript.ru/proxy
//--------------------------------------------------------------------
                                                      //GET
// Чтобы перехватить операцию чтения, handler должен иметь метод get(target, property, receiver).
//
//Он срабатывает при попытке прочитать свойство объекта, с аргументами:
//
//     target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
//     property – имя свойства,
//     receiver – если свойство объекта является геттером, то receiver – это объект, который будет использован как this при его вызове. Обычно это сам объект прокси (или наследующий от него объект). Прямо сейчас нам не понадобится этот аргумент, подробнее разберём его позже.

// сделаем числовой массив, так чтобы при чтении из него несуществующего элемента возвращался 0.
//
// Обычно при чтении из массива несуществующего свойства возвращается undefined, но мы обернём обычный массив в прокси, который перехватывает операцию чтения свойства из массива и возвращает 0, если такого элемента нет:

// let numbers = [0, 1, 2];
//
// numbers = new Proxy(numbers, {
//     get(target, prop) {
//         if (prop in target) {
//             return target[prop];
//         } else {
//             return 0; // значение по умолчанию
//         }
//     }
// });
//
// console.log( numbers[1] ); // 1
// console.log( numbers[123] ); // 0 (нет такого элемента)

//----------------------------------------------------------------------

// let dictionary = {
//     'Hello': 'Hola',
//     'Bye': 'Adiós'
// };
//
// console.log( dictionary['Hello'] ); // Hola
// console.log( dictionary['Welcome'] ); // undefined
//
// dictionary = new Proxy(dictionary, {
//     get(target, phrase) { // перехватываем чтение свойства в dictionary
//         if (phrase in target) { // если перевод для фразы есть в словаре
//             return target[phrase]; // возвращаем его
//         } else {
//             // иначе возвращаем непереведённую фразу
//             return phrase;
//         }
//     }
// });
// //
// // // Запросим перевод произвольного выражения в словаре!
// // // В худшем случае оно не будет переведено
// console.log( dictionary['Hello'] ); // Hola
// console.log( dictionary['Welcome to Proxy']); // Welcome to Proxy (нет перевода)

// !!! прокси перезаписывает переменную. Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться. -> dictionary = new Proxy(dictionary, ...);

//------------------------------------------------------------------------

                                                    //SET

// Ловушка set срабатывает, когда происходит запись свойства.
//
// set(target, property, value, receiver):
//
// target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
//     property – имя свойства,
//     value – значение свойства,
//     receiver – аналогично ловушке get, этот аргумент имеет значение, только если свойство – сеттер.
//     Ловушка set должна вернуть true, если запись прошла успешно, и false в противном случае (будет сгенерирована ошибка TypeError).


// let numbers = [];
//
// numbers = new Proxy(numbers, { //
//     set(target, prop, val) { // для перехвата записи свойства
//         if (typeof val == 'number') {
//             target[prop] = val;
//             return true;
//         } else {
//             return false;
//         }
//     }
// });
//
// numbers.push(1); // добавилось успешно
// numbers.push(2); // добавилось успешно
// // console.log("Длина: " + numbers.length); // 2
//
// numbers.push("тест"); // TypeError (ловушка set на прокси вернула false)
//
// console.log("Интерпретатор никогда не доходит до этой строки (из-за ошибки в строке выше)");

// !!! Для set реализация ловушки должна возвращать true в случае успешной записи свойства. Если забыть это сделать или возвратить любое ложное значение, это приведёт к ошибке TypeError.

//-------------------------------------------------------------------------------------------

                                                    //ownKeys

// Object.keys, цикл for..in и большинство других методов, которые работают со списком свойств объекта, используют внутренний метод [[OwnPropertyKeys]] (перехватываемый ловушкой ownKeys) для их получения.
//
//     Такие методы различаются в деталях:
//
//     Object.getOwnPropertyNames(obj) возвращает не-символьные ключи(числа, булевые значения, объекты или функции).
//     Object.getOwnPropertySymbols(obj) возвращает символьные ключи.
//     Object.keys/values() возвращает не-символьные ключи/значения с флагом enumerable
//     for..in перебирает не-символьные ключи с флагом enumerable, а также ключи прототипов.
//
//     В примере ниже мы используем ловушку ownKeys, чтобы цикл for..in по объекту, равно как Object.keys и
//     Object.values не считывали свойства, начинающиеся с подчёркивания _:

// let user = {
//     name: "Вася",
//     age: 30,
//     _password: "***"
// };
//
// user = new Proxy(user, {
//     ownKeys(target) {
//         return Object.keys(target).filter(key => !key.startsWith('_'));
//     }
// });

// ownKeys исключил _password
// for(let key in user) console.log(key); // name, затем: age

// аналогичный эффект для этих методов:
// console.log( Object.keys(user) ); // name,age
// console.log( Object.values(user) ); // Вася,30

// Впрочем, если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то Object.keys его не выдаст:

//     let user = { };
//
// user = new Proxy(user, {
//     ownKeys(target) {
//         return ['a', 'b', 'c'];
//     }
// });
//
// console.log( Object.keys(user) ); // <пусто>

//Почему? Причина проста: Object.keys возвращает только свойства с флагом enumerable

//Флаг enumerable является одним из свойств дескриптора свойства объекта в JavaScript. Он определяет, будет ли свойство перечисляемым при итерации через цикл for...in или при вызове методов Object.keys() или Object.values().
//
//Когда свойство имеет установленный флаг enumerable со значением true, оно будет перечисляемым и доступным при итерации через цикл for...in или при вызове методов Object.keys() или Object.values(). По умолчанию все свойства, созданные с помощью литерала объекта или метода Object.defineProperty(), имеют флаг enumerable со значением true.
//
//Однако, если свойство имеет установленный флаг enumerable со значением false, оно не будет перечисляемым и будет игнорироваться при итерации через цикл for...in или вызове методов Object.keys() и Object.values().

//
// Чтобы Object.keys возвращал свойство, нужно либо чтобы свойство в объекте физически было, причём с флагом enumerable, либо перехватить вызовы [[GetOwnProperty]] (это делает ловушка getOwnPropertyDescriptor), и там вернуть дескриптор с enumerable: true.

// let user = { };
//
// user = new Proxy(user, {
//     ownKeys(target) { // вызывается 1 раз для получения списка свойств
//         return ['a', 'b', 'c'];
//     },
//
//     getOwnPropertyDescriptor(target, prop) { // вызывается для каждого свойства
//         return {
//             enumerable: true,
//             configurable: true
//             /* ...другие флаги, возможно, "value: ..." */
//         };
//     }
//
// });
//
// console.log( Object.keys(user) ); // a, b, c
//
// получение дескриптора нужно перехватывать только если свойство отсутствует в самом объекте


//защищенные свойства

// свойства и методы, название которых начинается с символа подчёркивания _, следует считать внутренними. К ним не следует обращаться снаружи объекта.
// Однако технически это всё равно возможно:

// let user = {
//     name: "Вася",
//     _password: "secret"
// };
//
// console.log(user._password); // secret

// применим прокси, чтобы защитить свойства, начинающиеся на _, от доступа извне.
//     Нам будут нужны следующие ловушки:
//     get – для того, чтобы сгенерировать ошибку при чтении такого свойства,
//     set – для того, чтобы сгенерировать ошибку при записи,
//     deleteProperty – для того, чтобы сгенерировать ошибку при удалении,
//     ownKeys – для того, чтобы исключить такие свойства из for..in и методов типа Object.keys.

// let user = {
//     name: "Вася",
//     _password: "***"
// };
//
// user = new Proxy(user, {
//     get(target, prop) {
//         if (prop.startsWith('_')) {
//             throw new Error("Отказано в доступе");
//         } else {
//             let value = target[prop];
//             return (typeof value === 'function') ? value.bind(target) : value; // (*)
//         }
//     },
//     set(target, prop, val) { // перехватываем запись свойства
//         if (prop.startsWith('_')) {
//             throw new Error("Отказано в доступе");
//         } else {
//             target[prop] = val;
//             return true;
//         }
//     },
//     deleteProperty(target, prop) { // перехватываем удаление свойства
//         if (prop.startsWith('_')) {
//             throw new Error("Отказано в доступе");
//         } else {
//             delete target[prop];
//             return true;
//         }
//     },
//     ownKeys(target) { // перехватываем попытку итерации
//         return Object.keys(target).filter(key => !key.startsWith('_'));
//     }
// });

// "get" не позволяет прочитать _password
// try {
//     console.log(user._password); // Error: Отказано в доступе
// } catch(e) { console.log(e.message); }

// "set" не позволяет записать _password
// try {
//     user._password = "test"; // Error: Отказано в доступе
// } catch(e) { console.log(e.message); }

// "deleteProperty" не позволяет удалить _password
// try {
//     delete user._password; // Error: Отказано в доступе
// } catch(e) { console.log(e.message); }

// "ownKeys" исключает _password из списка видимых для итерации свойств
// for(let key in user) console.log(key); // name

// Зачем для функции вызывать value.bind(target)?
//
// Всё дело в том, что метод самого объекта, например user.checkPassword(), должен иметь доступ к свойству _password:
//
//     user = {
//         // ...
//         checkPassword(value) {
//             // метод объекта должен иметь доступ на чтение _password
//             return value === this._password;
//         }
//     }
//
// Вызов user.checkPassword() получает проксированный объект user в качестве this (объект перед точкой становится this), так что когда такой вызов обращается к this._password, ловушка get вступает в действие (она срабатывает при любом чтении свойства), и выбрасывается ошибка.
//
// Поэтому мы привязываем контекст к методам объекта – оригинальный объект target в строке (*). Тогда их дальнейшие вызовы будут использовать target в качестве this, без всяких ловушек.
//
// Такое решение обычно работает, но не является идеальным, поскольку метод может передать оригинальный объект куда-то ещё, и возможна путаница: где изначальный объект, а где – проксированный.

// Современные интерпретаторы JavaScript поддерживают приватные свойства в классах. Названия таких свойств должны начинаться с символа #. Они подробно описаны в главе Приватные и защищённые методы и свойства. Для них не нужны подобные прокси.
//
// Впрочем, приватные свойства имеют свои недостатки. В частности, они не наследуются.

//-------------------------------------------------------------------------------------------

                                                            //HAS

// let range = {
//     start: 1,
//     end: 10
// };

// Мы бы хотели использовать оператор in, чтобы проверить, что некоторое число находится в указанном диапазоне.
//
// Ловушка has перехватывает вызовы in.
//
// has(target, property)
//
// target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
// property – имя свойства

// let range = {
//     start: 1,
//     end: 10
// };
//
// range = new Proxy(range, {
//     has(target, prop) {
//         return prop >= target.start && prop <= target.end
//     }
// });
//
// console.log(5 in range); // true
// console.log(50 in range); // false

//------------------------------------------------------------------------------

                                        //apply

// Ловушка apply(target, thisArg, args) активируется при вызове прокси как функции:
//
//target – это оригинальный объект (как мы помним, функция – это объект в языке JavaScript),
//thisArg – это контекст this.
//args – список аргументов.

// function delay(f, ms) {
//     return new Proxy(f, {
//         apply(target, thisArg, args) {
//             setTimeout(() => target.apply(thisArg, args), ms);
//         }
//     });
// }
//
// function sayHi(user) {
//     console.log(`Привет, ${user}!`);
// }
//
// sayHi = delay(sayHi, 3000);
//
// console.log(sayHi.length); // 1 (*) прокси перенаправляет чтение свойства length на исходную функцию
//
// sayHi("Вася"); // Привет, Вася! (через 3 секунды)

                                                  // Reflect

// внутренние методы, такие как [[Get]], [[Set]] и другие, существуют только в спецификации, что к ним нельзя обратиться напрямую.
// Объект Reflect делает это возможным. Его методы – минимальные обёртки вокруг внутренних методов.

// https://learn.javascript.ru/proxy#reflect

// let user = {};
//
// Reflect.set(user, 'name', 'Вася');
//
// console.log(user.name); // Вася

// Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.

// мы можем использовать Reflect, чтобы перенаправить операцию на исходный объект.
//
// В этом примере обе ловушки get и set прозрачно (как будто их нет) перенаправляют операции чтения и записи на объект, при этом выводя сообщение:

// let user = {
//     name: "Вася",
// };
//
// user = new Proxy(user, {
//     get(target, prop, receiver) {
//         alert(`GET ${prop}`);
//         return Reflect.get(target, prop, receiver);
//     },
//     set(target, prop, val, receiver) {
//         alert(`SET ${prop}=${val}`);
//         return Reflect.set(target, prop, val, receiver);
//     }
// });
//
// let name = user.name; // выводит "GET name"
// user.name = "Петя"; // выводит "SET name=Петя"

// Reflect.get читает свойство объекта.
// Reflect.set записывает свойство и возвращает true при успехе, иначе false.
// То есть, всё очень просто – если ловушка хочет перенаправить вызов на объект, то достаточно вызвать Reflect.<метод> с теми же аргументами.

                                        //Прокси для геттера

// let user = {
//     _name: "Гость",
//     get name() {
//         return this._name;
//     }
// };
//
// let userProxy = new Proxy(user, {
//     get(target, prop, receiver) {
//         return target[prop];
//     }
// });
//
// console.log(userProxy.name); // Гость

// Если мы унаследуем от проксированного user объект admin, то мы увидим, что он ведёт себя некорректно

// let user = {
//     _name: "Гость",
//     get name() {
//         return this._name;
//     }
// };
//
// let userProxy = new Proxy(user, {
//     get(target, prop, receiver) {
//         return target[prop]; // (*) target = user
//     }
// });
//
// let admin = {
//     __proto__: userProxy,
//     _name: "Админ"
// };
//
// // Ожидается: Админ
// console.log(admin.name); // выводится Гость (?!?)

// проблема в прокси, в строке (*).
//
// При чтении admin.name, так как в объекте admin нет свойства name, оно ищется в прототипе. ?????
//
//Прототипом является прокси userProxy.
//
//При чтении из прокси свойства name срабатывает ловушка get и возвращает его из исходного объекта как target[prop] в строке (*).
//
// Вызов target[prop], если prop – это геттер, запускает его код в контексте this=target. Поэтому результатом является this._name из исходного объекта target, то есть из user.
//
// Именно для исправления таких ситуаций нужен receiver, третий аргумент ловушки get. В нём хранится ссылка на правильный контекст this, который нужно передать геттеру. В данном случае это admin.

// let user = {
//     _name: "Гость",
//     get name() {
//         return this._name;
//     }
// };
//
// let userProxy = new Proxy(user, {
//     get(target, prop, receiver) { // receiver = admin
//         return Reflect.get(target, prop, receiver); // (*)
//     }
// });
//
//
// let admin = {
//     __proto__: userProxy,
//     _name: "Админ"
// };
//
// console.log(admin.name); // Админ
// Сейчас receiver, содержащий ссылку на корректный this (то есть на admin), передаётся геттеру посредством Reflect.get в строке

// get(target, prop, receiver) {
//     return Reflect.get(...arguments);
// }

                                            //Ограничения прокси

//Встроенные объекты: внутренние слоты

// Многие встроенные объекты, например Map, Set, Date, Promise и другие используют так называемые «внутренние слоты».
//
// Это как свойства, но только для внутреннего использования в самой спецификациии. Например, Map хранит элементы во внутреннем слоте [[MapData]]. Встроенные методы обращаются к слотам напрямую, не через [[Get]]/[[Set]]. Таким образом, прокси не может перехватить их.
//
// Есть один нюанс. Если встроенный объект проксируется, то в прокси не будет этих «внутренних слотов», так что попытка вызвать на таком прокси встроенный метод приведёт к ошибке.

// let map = new Map();
//
// let proxy = new Proxy(map, {});
//
// proxy.set('test', 1); // будет ошибка
//
//
// let map = new Map();
//
// let proxy = new Proxy(map, {
//     get(target, prop, receiver) {
//         let value = Reflect.get(...arguments);
//         return typeof value == 'function' ? value.bind(target) : value;
//     }
// });
//
// proxy.set('test', 1);
// console.log(proxy.get('test')); // 1 (работает!)

//Объект Array не использует внутренние слоты

                                               //Приватные поля

// Например, метод getName() осуществляет доступ к приватному полю #name, после проксирования он перестаёт работать:

//     class User {
//         #name = "Гость";
//
//         getName() {
//             return this.#name;
//         }
//     }
//
// let user = new User();
//
// user = new Proxy(user, {});
//
// console.log(user.getName()); // Ошибка

// Причина всё та же: приватные поля реализованы с использованием внутренних слотов. JavaScript не использует [[Get]]/[[Set]] при доступе к ним.
// В вызове getName() значением this является проксированный user, в котором нет внутреннего слота с приватными полями.
// //
// class User {
//     #name = "Гость";
//
//     getName() {
//         return this.#name;
//     }
// }
//
// let user = new User();
//
// user = new Proxy(user, {
//     get(target, prop, receiver) {
//         let value = Reflect.get(...arguments);
//         return typeof value == 'function' ? value.bind(target) : value;
//     }
// });
//
// console.log(user.getName()); // Гость

//Прокси != оригинальный объект

// Прокси и объект, который проксируется, являются двумя разными объектами. Это естественно, не правда ли?
// Если мы используем оригинальный объект как ключ, а затем проксируем его, то прокси не будет найден:

// let allUsers = new Set();
//
// class User {
//     constructor(name) {
//         this.name = name;
//         allUsers.add(this);
//     }
// }
//
// let user = new User("Вася");
//
// console.log(allUsers.has(user)); // true
//
// user = new Proxy(user, {});
//
// console.log(allUsers.has(user)); // false

// Как мы видим, после проксирования не получается найти объект user внутри множества allUsers, потому что прокси – это другой объект.

// Прокси не перехватывают проверку на строгое равенство ===
// Но нет способа перехватить проверку на строгое равенство. Объект строго равен только самому себе, и никаким другим значениям.
// Так что все операции и встроенные классы, которые используют строгую проверку объектов на равенство, отличат прокси от изначального объекта.

                                         //Отключаемые прокси

// Отключаемый (revocable) прокси – это прокси, который может быть отключён вызовом специальной функции.
// Допустим, у нас есть какой-то ресурс, и мы бы хотели иметь возможность закрыть к нему доступ в любой момент.
// Для того, чтобы решить поставленную задачу, мы можем использовать отключаемый прокси, без ловушек. Такой прокси будет передавать все операции на проксируемый объект, и у нас будет возможность в любой момент отключить это.

// let {proxy, revoke} = Proxy.revocable(target, handler)


// let object = {
//     data: "Важные данные"
// };
//
// let {proxy, revoke} = Proxy.revocable(object, {});
//
// // передаём прокси куда-нибудь вместо оригинального объекта...
// console.log(proxy.data); // Важные данные
//
// // позже в коде
// revoke();
//
// // прокси больше не работает (отключён)
// console.log(proxy.data); // Ошибка

// Вызов revoke() удаляет все внутренние ссылки на оригинальный объект из прокси, так что между ними больше нет связи, и оригинальный объект теперь может быть очищен сборщиком мусора.
// Мы можем хранить функцию revoke в WeakMap, чтобы легко найти её по объекту прокси:

// let revokes = new WeakMap();
//
// let object = {
//     data: "Важные данные"
// };
//
// let {proxy, revoke} = Proxy.revocable(object, {});
//
// revokes.set(proxy, revoke);
//
// // ..позже в коде..
// revoke = revokes.get(proxy);
// revoke();
//
// alert(proxy.data); // Ошибка (прокси отключён)

// Преимущество такого подхода в том, что мы не должны таскать функцию revoke повсюду. Мы получаем её при необходимости из revokes по объекту прокси. Мы использовали WeakMap вместо Map, чтобы не блокировать сборку мусора. Если прокси объект становится недостижимым (то есть на него больше нет ссылок), то WeakMap позволяет сборщику мусора удалить его из памяти вместе с соответствующей функцией revoke, которая в этом случае больше не нужна.


// WeakMap является встроенной структурой данных в JavaScript, которая представляет собой коллекцию пар ключ-значение, где ключи могут быть только объектами, а значения могут быть любыми.



// Напишите функцию wrap(target), которая берёт объект target и возвращает прокси,  определяющий наличие свойства в
// объекте

// let user = {
//     name: "John"
// };
//
// function wrap(target) {
//     return new Proxy(target, {
//         /* ваш код */
//
//     });
// }
//
// user = wrap(user);
//
// console.log(user.name); // John
// console.log(user.age); // Ошибка: такого свойства не существует




// Создайте прокси, который реализовывал бы такое поведение.
//
//     Вот как это должно работать:
//
//     let array = [1, 2, 3];
//
// array = new Proxy(array, {
//     /* ваш код */
// });
//
// console.log( array[-1] ); // 3
// console.log( array[-2] ); // 2


// Создайте функцию makeObservable(target), которая делает объект «наблюдаемым», возвращая прокси.
// Другими словами, возвращаемый makeObservable объект аналогичен исходному, но также имеет метод observe(handler), который позволяет запускать handler при любом изменении свойств.
//  При изменении любого свойства вызывается handler(key, value) с именем и значением свойства.
// P.S. В этой задаче ограничьтесь, пожалуйста, только записью свойства. Остальные операции могут быть реализованы похожим образом.
//
// function makeObservable(target) {
//     /* ваш код */
// }
//
// let user = {};
// user = makeObservable(user);
//
// user.observe((key, value) => {
//     alert(`SET ${key}=${value}`);
// });
//
// user.name = "John"; // выводит: SET name=John



//
// makeObservable(target)
// Решение состоит из двух частей:
//
//     При вызове .observe(handler) нам нужно где-то сохранить обработчик, чтобы вызвать его позже. Можно хранить обработчики прямо в объекте, создав в нём для этого свой символьный ключ.
//     Нам нужен прокси с ловушкой set, чтобы вызывать обработчики при изменении свойств.

//
//     let handlers = Symbol('handlers');
//
// function makeObservable(target) {
//     // 1. Создадим хранилище обработчиков
//     target[handlers] = [];
//
//     // положим туда функции-обработчики для вызовов в будущем
//     target.observe = function(handler) {
//         this[handlers].push(handler);
//     };
//
//     // 2. Создадим прокси для реакции на изменения
//     return new Proxy(target, {
//         set(target, property, value, receiver) {
//             let success = Reflect.set(...arguments); // перенаправим операцию к оригинальному объекту
//             if (success) { // если не произошло ошибки при записи свойства
//                 // вызовем обработчики
//                 target[handlers].forEach(handler => handler(property, value));
//             }
//             return success;
//         }
//     });
// }

// let user = {};
//
// user = makeObservable(user);
//
// user.observe((key, value) => {
//     alert(`SET ${key}=${value}`);
// });
//
// user.name = "John";


// Напишите функцию-валидатор для объекта, которая будет проверять значения свойств объекта и возвращать различные сообщения в зависимости от условий.

// // Пример использования функции-валидатора
// validator.age = 25; // Установка корректного значения свойства "age"
// validator.age = -10; // Вывод: "Некорректный возраст"
// validator.email = 'example.com'; // Вывод: "Некорректный email"
// validator.email = 'john@example.com'; // Установка корректного значения свойства "email"
// validator.name = 'John'; // Установка значения свойства "name" без проверки

